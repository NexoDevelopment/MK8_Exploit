#include "entry.h"
#include "main_hook.h"
#include "elf_stuff.h"

#define COREINIT(x) (x - 0xFE3C00) // From IDA

/* OS Cache functions */
void (*DCFlushRange)(void *buffer, uint32_t length);
void (*DCInvalidateRange)(void *buffer, uint32_t length);
void (*ICInvalidateRange)(void *buffer, uint32_t length);
uint32_t (*OSEffectiveToPhysical)(uint32_t addr);
void (*OSFatal)(char *msg);

static void setup_syscall(void) {
    // set kernel code area write permissions
    asm volatile("mtspr 570, %0" : : "r" (0xFFF00002));
    asm volatile("mtspr 571, %0" : : "r" (0xFFF00032));
    asm volatile("eieio; isync");

    uint32_t *targetAddress = (uint32_t*)0xFFF02344;
    targetAddress[0] = 0x7C0006AC;
    targetAddress[1] = 0x4C00012C;
	targetAddress[2] = 0x7C7083A6;
	targetAddress[3] = 0x7C9183A6;
	targetAddress[4] = 0x7C0006AC;
	targetAddress[5] = 0x4C00012C;
	targetAddress[6] = 0x4E800020;
	asm volatile("dcbf 0, %0; icbi 0, %0; sync" : : "r" (0xFFF02340));
    asm volatile("dcbf 0, %0; icbi 0, %0; sync" : : "r" (0xFFF02360));

}

int __entry(int argc, char **argv)
{
	DCFlushRange = (void*)COREINIT(0x02007B88);
	DCInvalidateRange = (void*)COREINIT(0x02007B5C);
	ICInvalidateRange = (void*)COREINIT(0x02007CB0);
	OSEffectiveToPhysical = (void*)COREINIT(0x02003120);
	OSFatal = (void*)0x01031618;

	uint32_t syscalls[2] = {0xFFF023D4, 0xFFF023F4};

	Syscall_0x25((void*)(KERN_SYSCALL_TBL_1 + (0x34 * 4)), syscalls, 8);
	Syscall_0x25((void*)(KERN_SYSCALL_TBL_2 + (0x34 * 4)), syscalls, 8);
	Syscall_0x25((void*)(KERN_SYSCALL_TBL_3 + (0x34 * 4)), syscalls, 8);
	Syscall_0x25((void*)(KERN_SYSCALL_TBL_4 + (0x34 * 4)), syscalls, 8);
	Syscall_0x25((void*)(KERN_SYSCALL_TBL_5 + (0x34 * 4)), syscalls, 8);

	uint32_t *targetAddress = (uint32_t*)(0xA0000000 + (0x327FF000 - 0x10000000));

	targetAddress[0] = 0x7c7082a6;                          // mfspr r3, 528
	targetAddress[1] = 0x60630003;                          // ori r3, r3, 0x03
	targetAddress[2] = 0x7c7083a6;                          // mtspr 528, r3
	targetAddress[3] = 0x7c7282a6;                          // mfspr r3, 530
	targetAddress[4] = 0x60630003;                          // ori r3, r3, 0x03
	targetAddress[5] = 0x7c7283a6;                          // mtspr 530, r3
	targetAddress[6] = 0x7c0006ac;                          // eieio
	targetAddress[7] = 0x4c00012c;                          // isync
	targetAddress[8] = 0x3c600000 | (((uint32_t)setup_syscall) >> 16);     // lis r3, setup_syscall@h
	targetAddress[9] = 0x60630000 | (((uint32_t)setup_syscall) & 0xFFFF);  // ori r3, r3, setup_syscall@l
	targetAddress[10] = 0x7c6903a6;                         // mtctr   r3
	targetAddress[11] = 0x4e800420;                         // bctr
	DCFlushRange(targetAddress, 0x100);
	ICInvalidateRange(targetAddress, 0x100);

	/* set our setup syscall to our shit */
	kern_write((void*)(KERN_SYSCALL_TBL_1 + (0x25 * 4)), 0x017FF000);
	kern_write((void*)(KERN_SYSCALL_TBL_2 + (0x25 * 4)), 0x017FF000);
	kern_write((void*)(KERN_SYSCALL_TBL_3 + (0x25 * 4)), 0x017FF000);
	kern_write((void*)(KERN_SYSCALL_TBL_4 + (0x25 * 4)), 0x017FF000);
	kern_write((void*)(KERN_SYSCALL_TBL_5 + (0x25 * 4)), 0x017FF000);

	Syscall_0x25(NULL, NULL, 0);

	// Setup as syscall 0x09
	kern_write((void*)(KERN_SYSCALL_TBL_1 + (0x09 * 4)), 0xFFF02344);
	kern_write((void*)(KERN_SYSCALL_TBL_2 + (0x09 * 4)), 0xFFF02344);
	kern_write((void*)(KERN_SYSCALL_TBL_3 + (0x09 * 4)), 0xFFF02344);
	kern_write((void*)(KERN_SYSCALL_TBL_4 + (0x09 * 4)), 0xFFF02344);
	kern_write((void*)(KERN_SYSCALL_TBL_5 + (0x09 * 4)), 0xFFF02344);

	uint8_t* LoaderELF = (uint8_t *)main_hook_elf;
	install_section(LoaderELF, ".text");
	install_section(LoaderELF, ".data");

	Elf32_Ehdr *ehdr = (Elf32_Ehdr *)main_hook_elf;

	uint32_t yeet_instruction = ((ehdr->e_entry & 0x03FFFFFC) | 0x48000003);
	uint8_t *destAddr = (uint8_t*)(0xA0000000 + (OSEffectiveToPhysical(0x0101c56c) - 0x10000000));

	DCFlushRange(&yeet_instruction , 4);
	memcpy(destAddr, &yeet_instruction, 4);
	DCFlushRange((void*)0x0101c56c, 4);
	ICInvalidateRange((void*)0x0101c56c, 4);

	int (*const OSDynLoad_Acquire)(const char* lib_name, int* out_addr) = (void*)COREINIT(0x0200DFB4);
	int (*const OSDynLoad_FindExport)(int lib_handle, int flags, const char* name, void* out_addr) = (void*)COREINIT(0x0200F428);

		int sysapp_handle, coreinit_handle;
	void (*_SYSLaunchMiiStudio)(void) = 0;
	void (*_Exit)(int code) = 0;
	OSDynLoad_Acquire("sysapp.rpl", &sysapp_handle);
	OSDynLoad_Acquire("coreinit.rpl", &coreinit_handle);
	OSDynLoad_FindExport(sysapp_handle, 0, "_SYSLaunchMiiStudio", &_SYSLaunchMiiStudio);
	OSDynLoad_FindExport(coreinit_handle, 0, "_Exit", &_Exit);

	_SYSLaunchMiiStudio();

	uint32_t fptr = *(uint32_t*)0x1005E040;
	int (*real_entry)(int argc, char **argv) = (int(*)(int, char**))fptr;

	return real_entry(argc, argv);
}